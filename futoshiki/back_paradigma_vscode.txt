import copy
import numpy as np
import argparse
import sys
import time

SIZE = 4  # Define o tamanho do tabuleiro

def listify(lst):
    '''
    turns the states into list of lists
    returnlst = list of lists (2D matrix for the puzzle)
    '''
    returnlst = []
    for item in lst:
        # Mantém caracteres não numéricos como estão (para restrições)
        # Converte apenas strings puramente numéricas para int
        nums = [int(x) if x.isdigit() else x for x in item.split()]
        returnlst.append(nums)
    return returnlst

def printlst(lst, f):
    '''
    formatting the list to print out each item in the list
    '''
    for item in lst:
        for enter in item:
            f.write(str(enter))
            f.write(" ")
        f.write('\n')
    f.write('\n')

class BackTracker():
    class Board():
        def __init__(self, puzzle_arr, dom_arr, h_const, v_const, parent=None):
            self.size = SIZE  # Usar a constante global
            self.puzzle = puzzle_arr  # e.g., np.array([[1,2,3,4],[...]])
            self.domains = dom_arr  # list of list of sets [[{1,2,3,4},{},{}],[]]

            self.h_const = h_const  # Dicionário: {(linha, col_esq): 0 (<) ou 1 (>)}
            self.v_const = v_const  # Dicionário: {(linha_cima, col): 0 (v) ou 1 (^)}

            self.children = []
            self.parent = parent

            self.target = (0, 0)  # Coordenada (linha, col) da próxima variável a ser atribuída
            self.target_vals = []  # Lista de valores possíveis para self.target
            self.target_index = 0  # Índice do valor atual sendo tentado em self.target_vals

        def initialize(self):
            # initializes dom_arr to {1,2,3,4} for all cells
            self.domains = [[set() for _ in range(self.size)] for _ in range(self.size)]
            for row in range(self.size):
                for col in range(self.size):
                    if self.puzzle[row][col] == 0:  # Inicializa domínio apenas para células vazias
                        self.domains[row][col] = set(range(1, self.size + 1))
                    else:
                        self.domains[row][col] = {self.puzzle[row][col]}  # Domínio com o valor atual para células preenchidas

        def isValid(self):
            # 1. checks for empty set after update (consistency check)
            for row in range(self.size):
                for col in range(self.size):
                    if self.puzzle[row][col] == 0 and len(self.domains[row][col]) == 0:
                        return False

            # 2. row column uniqueness checking (Sudoku rule)
            for r in range(self.size):
                row_vals = [self.puzzle[r][c] for c in range(self.size) if self.puzzle[r][c] != 0]
                if len(row_vals) != len(set(row_vals)):
                    return False
            for c in range(self.size):
                col_vals = [self.puzzle[r][c] for r in range(self.size) if self.puzzle[r][c] != 0]
                if len(col_vals) != len(set(col_vals)):
                    return False

            # 3. horizontal and vertical constraints checking
            for h_coord, ineq in self.h_const.items():
                left_r, left_c = h_coord
                right_r, right_c = left_r, left_c + 1
                left_val = self.puzzle[left_r][left_c]
                right_val = self.puzzle[right_r][right_c]

                if left_val != 0 and right_val != 0:
                    if ineq == 1:  # left > right
                        if not left_val > right_val:
                            return False
                    elif ineq == 0:  # left < right
                        if not left_val < right_val:
                            return False

            for v_coord, ineq in self.v_const.items():
                up_r, up_c = v_coord
                down_r, down_c = up_r + 1, up_c
                up_val = self.puzzle[up_r][up_c]
                down_val = self.puzzle[down_r][down_c]

                if up_val != 0 and down_val != 0:
                    if ineq == 1:  # up > down (^)
                        if not up_val > down_val:
                            return False
                    elif ineq == 0:  # up < down (v)
                        if not up_val < down_val:
                            return False
            return True

# Dentro da classe BackTracker.Board:

        def update(self):
            # Versão CONFIÁVEL: Forward Checking iterativo + Desigualdades
            # Retorna False se uma inconsistência for encontrada, True caso contrário.
            
            made_change_in_pass = True
            while made_change_in_pass: # Repete enquanto houver mudanças nos domínios
                made_change_in_pass = False

                # 1. Restrições de Unicidade (Sudoku - Forward Checking)
                for r in range(self.size):
                    for c in range(self.size):
                        if self.puzzle[r][c] != 0: # Se a célula está preenchida
                            assigned_val = self.puzzle[r][c]
                            
                            # Garante que o domínio da célula preenchida tenha apenas esse valor
                            # (ou esteja vazio se já processado)
                            if self.domains[r][c] != {assigned_val} and self.domains[r][c] != set():
                                # Se o domínio ainda não foi definido para apenas o valor atribuído,
                                # pode ser um estado inicial ou um erro. Ajustamos.
                                # No backtracking normal, new_domains[target_r][target_c] = {val_to_try}
                                # garante isso ao descer. Mas para robustez, verificamos.
                                self.domains[r][c] = {assigned_val} 
                                # Consideramos isso uma mudança interna, não afeta made_change_in_pass aqui.
                                # A remoção dos domínios vizinhos é o que importa para a propagação.

                            # Remove o valor das outras células na mesma linha
                            for col_other in range(self.size):
                                if col_other != c and assigned_val in self.domains[r][col_other]:
                                    self.domains[r][col_other].discard(assigned_val)
                                    if not self.domains[r][col_other]: return False # Inconsistência!
                                    made_change_in_pass = True

                            # Remove o valor das outras células na mesma coluna
                            for row_other in range(self.size):
                                if row_other != r and assigned_val in self.domains[row_other][c]:
                                    self.domains[row_other][c].discard(assigned_val)
                                    if not self.domains[row_other][c]: return False # Inconsistência!
                                    made_change_in_pass = True

                # 2. Restrições de Desigualdade (Maior/Menor)
                # Horizontal
                for h_coord, ineq in self.h_const.items():
                    left_r, left_c = h_coord
                    # Verifica limites antes de acessar right_c
                    if left_c + 1 >= self.size: continue 
                    right_r, right_c = left_r, left_c + 1
                    
                    left_val = self.puzzle[left_r][left_c]
                    right_val = self.puzzle[right_r][right_c]
                    domain_left = self.domains[left_r][left_c]
                    domain_right = self.domains[right_r][right_c]
                    original_len_l = len(domain_left)
                    original_len_r = len(domain_right)

                    # Caso 1: Esquerda preenchida, Direita vazia
                    if left_val != 0 and right_val == 0:
                        vals_to_remove = set()
                        if ineq == 1: # left > right
                            vals_to_remove = {d for d in domain_right if d >= left_val}
                        else: # left < right
                            vals_to_remove = {d for d in domain_right if d <= left_val}
                        
                        if vals_to_remove:
                            self.domains[right_r][right_c] -= vals_to_remove
                            if not self.domains[right_r][right_c]: return False # Inconsistência
                            if len(self.domains[right_r][right_c]) != original_len_r:
                                made_change_in_pass = True
                                
                    # Caso 2: Esquerda vazia, Direita preenchida
                    elif left_val == 0 and right_val != 0:
                        vals_to_remove = set()
                        if ineq == 1: # left > right
                            vals_to_remove = {d for d in domain_left if d <= right_val}
                        else: # left < right
                            vals_to_remove = {d for d in domain_left if d >= right_val}

                        if vals_to_remove:
                           self.domains[left_r][left_c] -= vals_to_remove
                           if not self.domains[left_r][left_c]: return False # Inconsistência
                           if len(self.domains[left_r][left_c]) != original_len_l:
                                made_change_in_pass = True

                    # Caso 3: Ambas vazias (poda simples baseada em limites)
                    elif left_val == 0 and right_val == 0:
                        if domain_left and domain_right: # Só faz sentido se ambos tiverem domínios
                             min_right, max_right = min(domain_right), max(domain_right)
                             min_left, max_left = min(domain_left), max(domain_left)
                             
                             vals_to_remove_l = set()
                             vals_to_remove_r = set()

                             if ineq == 1: # left > right
                                 # left não pode ser <= min(right) E right não pode ser >= max(left)
                                 vals_to_remove_l = {d for d in domain_left if d <= min_right} 
                                 vals_to_remove_r = {d for d in domain_right if d >= max_left}  
                             else: # left < right
                                 # left não pode ser >= max(right) E right não pode ser <= min(left)
                                 vals_to_remove_l = {d for d in domain_left if d >= max_right} 
                                 vals_to_remove_r = {d for d in domain_right if d <= min_left}  

                             if vals_to_remove_l:
                                 self.domains[left_r][left_c] -= vals_to_remove_l
                                 if not self.domains[left_r][left_c]: return False
                                 if len(self.domains[left_r][left_c]) != original_len_l: made_change_in_pass = True
                             
                             # Reavaliar domínios antes de aplicar a segunda poda, pois podem ter mudado
                             domain_left = self.domains[left_r][left_c] # Atualiza domain_left
                             if vals_to_remove_r and domain_left and self.domains[right_r][right_c]: # Verifica se ainda são válidos 
                                 # Recalcula max_left / min_left se necessário
                                 min_left, max_left = min(domain_left), max(domain_left)
                                 # Recalcula o conjunto a remover de R com base no L atualizado
                                 if ineq == 1: # left > right
                                      vals_to_remove_r = {d for d in self.domains[right_r][right_c] if d >= max_left}
                                 else: # left < right
                                      vals_to_remove_r = {d for d in self.domains[right_r][right_c] if d <= min_left}
                                      
                                 if vals_to_remove_r: # Verifica se ainda há algo a remover
                                     self.domains[right_r][right_c] -= vals_to_remove_r
                                     if not self.domains[right_r][right_c]: return False
                                     if len(self.domains[right_r][right_c]) != original_len_r: made_change_in_pass = True # Compara com original ainda? Ou recalcular? Melhor comparar com len atual se recalcula o conjunto
                                     # Simplificação: Se houve qualquer remoção, marcar made_change_in_pass = True
                
                # Vertical (lógica similar à horizontal)
                for v_coord, ineq in self.v_const.items():
                    up_r, up_c = v_coord
                    # Verifica limites antes de acessar down_r
                    if up_r + 1 >= self.size: continue
                    down_r, down_c = up_r + 1, up_c

                    up_val = self.puzzle[up_r][up_c]
                    down_val = self.puzzle[down_r][down_c]
                    domain_up = self.domains[up_r][up_c]
                    domain_down = self.domains[down_r][down_c]
                    original_len_u = len(domain_up)
                    original_len_d = len(domain_down)

                    # Caso 1: Cima preenchida, Baixo vazio
                    if up_val != 0 and down_val == 0:
                        vals_to_remove = set()
                        if ineq == 1: # up > down (^)
                             vals_to_remove = {d for d in domain_down if d >= up_val}
                        else: # up < down (v)
                            vals_to_remove = {d for d in domain_down if d <= up_val}
                        
                        if vals_to_remove:
                            self.domains[down_r][down_c] -= vals_to_remove
                            if not self.domains[down_r][down_c]: return False 
                            if len(self.domains[down_r][down_c]) != original_len_d: made_change_in_pass = True
                                
                    # Caso 2: Cima vazio, Baixo preenchido
                    elif up_val == 0 and down_val != 0:
                        vals_to_remove = set()
                        if ineq == 1: # up > down (^)
                            vals_to_remove = {d for d in domain_up if d <= down_val}
                        else: # up < down (v)
                             vals_to_remove = {d for d in domain_up if d >= down_val}

                        if vals_to_remove:
                            self.domains[up_r][up_c] -= vals_to_remove
                            if not self.domains[up_r][up_c]: return False 
                            if len(self.domains[up_r][up_c]) != original_len_u: made_change_in_pass = True

                    # Caso 3: Ambas vazias (poda simples baseada em limites)
                    elif up_val == 0 and down_val == 0:
                        if domain_up and domain_down:
                             min_down, max_down = min(domain_down), max(domain_down)
                             min_up, max_up = min(domain_up), max(domain_up)
                             
                             vals_to_remove_u = set()
                             vals_to_remove_d = set()

                             if ineq == 1: # up > down (^)
                                 vals_to_remove_u = {d for d in domain_up if d <= min_down}
                                 vals_to_remove_d = {d for d in domain_down if d >= max_up}
                             else: # up < down (v)
                                 vals_to_remove_u = {d for d in domain_up if d >= max_down}
                                 vals_to_remove_d = {d for d in domain_down if d <= min_up}

                             if vals_to_remove_u:
                                 self.domains[up_r][up_c] -= vals_to_remove_u
                                 if not self.domains[up_r][up_c]: return False
                                 if len(self.domains[up_r][up_c]) != original_len_u: made_change_in_pass = True

                             # Reavaliar antes da segunda poda
                             domain_up = self.domains[up_r][up_c] # Atualiza domain_up
                             if vals_to_remove_d and domain_up and self.domains[down_r][down_c]: 
                                 min_up, max_up = min(domain_up), max(domain_up)
                                 if ineq == 1: # up > down (^)
                                     vals_to_remove_d = {d for d in self.domains[down_r][down_c] if d >= max_up}
                                 else: # up < down (v)
                                      vals_to_remove_d = {d for d in self.domains[down_r][down_c] if d <= min_up}

                                 if vals_to_remove_d:
                                     self.domains[down_r][down_c] -= vals_to_remove_d
                                     if not self.domains[down_r][down_c]: return False
                                     if len(self.domains[down_r][down_c]) != original_len_d: made_change_in_pass = True

            # Fim do loop while made_change_in_pass
            return True # Se chegou aqui, o estado é consistente (pode não ser final)


        def chooseTargetVal(self):
            # Heurística MRV (Minimum Remaining Values) com desempate por Degree Heuristic
            mrv_lst = []
            least = self.size + 1  # Max domain size + 1

            for row in range(self.size):
                for col in range(self.size):
                    if self.puzzle[row][col] == 0:  # Consider only unassigned cells
                        curr_domain_len = len(self.domains[row][col])
                        if curr_domain_len == 0: # Se encontrar domínio vazio, retorna erro logo
                             self.target = (-1,-1)
                             self.target_vals = []
                             # print(f"AVISO: Domínio vazio encontrado em ({row},{col}) durante chooseTargetVal")
                             return 
                             
                        if curr_domain_len < least:
                            least = curr_domain_len
                            mrv_lst = [(row, col)]
                        elif curr_domain_len == least:
                            mrv_lst.append((row, col))

            if not mrv_lst:  # Se não há células vazias (completo) ou erro
                # Verificar se está completo
                if self.isComplete():
                     self.target = (-1,-1) # Indica conclusão
                     self.target_vals = []
                     return
                else:
                     # Isso não deveria acontecer se isComplete() é falso e há células vazias
                     # Mas pode ocorrer se uma célula vazia teve seu domínio esvaziado e não foi detectado antes
                     print('Erro: MRV_lst vazio, mas tabuleiro incompleto e sem domínios vazios detectados?')
                     self.target = (-1,-1) # Indica erro
                     self.target_vals = []
                     return


            # Degree Heuristic (desempate)
            if len(mrv_lst) > 1:
                degree_lst = []
                for r, c in mrv_lst:
                    degree = 0
                    # Conta vizinhos *não atribuídos* que participam de alguma restrição com (r,c)
                    # (Incluindo linha/coluna e desigualdades)
                    
                    # Linha (células não atribuídas na mesma linha)
                    for oc in range(self.size):
                         if oc != c and self.puzzle[r][oc] == 0: degree += 1
                    # Coluna (células não atribuídas na mesma coluna)
                    for or_ in range(self.size):
                         if or_ != r and self.puzzle[or_][c] == 0: degree += 1

                    # Desigualdades (Adiciona +1 se o vizinho da desigualdade não está atribuído)
                    # Esquerda
                    if c > 0 and (r, c - 1) in self.h_const and self.puzzle[r][c-1] == 0: degree +=1 
                    # Direita
                    if c < self.size - 1 and (r, c) in self.h_const and self.puzzle[r][c+1] == 0: degree +=1
                    # Cima
                    if r > 0 and (r - 1, c) in self.v_const and self.puzzle[r-1][c] == 0: degree += 1
                    # Baixo
                    if r < self.size - 1 and (r, c) in self.v_const and self.puzzle[r+1][c] == 0: degree += 1
                    
                    # Nota: Contar vizinhos na linha/coluna já conta parcialmente o grau. 
                    # A adição explícita das desigualdades pode inflar o grau, mas ajuda a priorizar
                    # células com mais restrições explícitas. Pode-se refinar essa contagem.
                    
                    degree_lst.append(degree)
                
                # Escolhe o com maior grau (mais restrições sobre vizinhos)
                # Em caso de empate no grau, mantém a ordem do MRV (geralmente determinístico)
                max_degree = -1
                chosen_target = mrv_lst[0] # Padrão
                for i in range(len(mrv_lst)):
                    if degree_lst[i] > max_degree:
                        max_degree = degree_lst[i]
                        chosen_target = mrv_lst[i]
                self.target = chosen_target
                
            else:
                self.target = mrv_lst[0]  # Só havia um com MRV

            # Pega os valores possíveis para o alvo escolhido, ordenados numericamente.
            self.target_vals = sorted(list(self.domains[self.target[0]][self.target[1]]))
            self.target_index = 0 # Resetar o índice para a nova variável        

        def chooseTargetVal(self):
            # Heurística MRV (Minimum Remaining Values) com desempate por Degree Heuristic
            mrv_lst = []
            least = self.size + 1  # Max domain size + 1

            for row in range(self.size):
                for col in range(self.size):
                    if self.puzzle[row][col] == 0:  # Consider only unassigned cells
                        curr_domain_len = len(self.domains[row][col])
                        if curr_domain_len == 0: # Se encontrar domínio vazio, retorna erro logo
                             self.target = (-1,-1)
                             self.target_vals = []
                             # print(f"AVISO: Domínio vazio encontrado em ({row},{col}) durante chooseTargetVal")
                             return 
                             
                        if curr_domain_len < least:
                            least = curr_domain_len
                            mrv_lst = [(row, col)]
                        elif curr_domain_len == least:
                            mrv_lst.append((row, col))

            if not mrv_lst:  # Se não há células vazias (completo) ou erro
                # Verificar se está completo
                if self.isComplete():
                     self.target = (-1,-1) # Indica conclusão
                     self.target_vals = []
                     return
                else:
                     # Isso não deveria acontecer se isComplete() é falso e há células vazias
                     # Mas pode ocorrer se uma célula vazia teve seu domínio esvaziado e não foi detectado antes
                     print('Erro: MRV_lst vazio, mas tabuleiro incompleto e sem domínios vazios detectados?')
                     self.target = (-1,-1) # Indica erro
                     self.target_vals = []
                     return


            # Degree Heuristic (desempate)
            if len(mrv_lst) > 1:
                degree_lst = []
                for r, c in mrv_lst:
                    degree = 0
                    # Conta vizinhos *não atribuídos* que participam de alguma restrição com (r,c)
                    # (Incluindo linha/coluna e desigualdades)
                    
                    # Linha (células não atribuídas na mesma linha)
                    for oc in range(self.size):
                         if oc != c and self.puzzle[r][oc] == 0: degree += 1
                    # Coluna (células não atribuídas na mesma coluna)
                    for or_ in range(self.size):
                         if or_ != r and self.puzzle[or_][c] == 0: degree += 1

                    # Desigualdades (Adiciona +1 se o vizinho da desigualdade não está atribuído)
                    # Esquerda
                    if c > 0 and (r, c - 1) in self.h_const and self.puzzle[r][c-1] == 0: degree +=1 
                    # Direita
                    if c < self.size - 1 and (r, c) in self.h_const and self.puzzle[r][c+1] == 0: degree +=1
                    # Cima
                    if r > 0 and (r - 1, c) in self.v_const and self.puzzle[r-1][c] == 0: degree += 1
                    # Baixo
                    if r < self.size - 1 and (r, c) in self.v_const and self.puzzle[r+1][c] == 0: degree += 1
                    
                    # Nota: Contar vizinhos na linha/coluna já conta parcialmente o grau. 
                    # A adição explícita das desigualdades pode inflar o grau, mas ajuda a priorizar
                    # células com mais restrições explícitas. Pode-se refinar essa contagem.
                    
                    degree_lst.append(degree)
                
                # Escolhe o com maior grau (mais restrições sobre vizinhos)
                # Em caso de empate no grau, mantém a ordem do MRV (geralmente determinístico)
                max_degree = -1
                chosen_target = mrv_lst[0] # Padrão
                for i in range(len(mrv_lst)):
                    if degree_lst[i] > max_degree:
                        max_degree = degree_lst[i]
                        chosen_target = mrv_lst[i]
                self.target = chosen_target
                
            else:
                self.target = mrv_lst[0]  # Só havia um com MRV

            # Pega os valores possíveis para o alvo escolhido, ordenados numericamente.
            self.target_vals = sorted(list(self.domains[self.target[0]][self.target[1]]))
            self.target_index = 0 # Resetar o índice para a nova variável

        def revise(self, i_r, i_c, j_r, j_c):
            """Revisa o arco (i, j) e remove valores do domínio de i que não são consistentes com j"""
            revised = False
            i_value = self.puzzle[i_r][i_c]  # Valor atual da célula i
            j_value = self.puzzle[j_r][j_c]  # Valor atual da célula j
            
            # Se ambas as células já têm valores atribuídos, nada a fazer
            if i_value != 0 and j_value != 0:
                return False
                
            # Se a célula i já tem um valor atribuído, seu domínio já é fixo
            if i_value != 0:
                return False
                
            # Se estamos na mesma linha, verificar restrições horizontais
            if i_r == j_r and abs(i_c - j_c) == 1:
                # Determinar qual é esquerda e qual é direita
                if i_c < j_c:  # i está à esquerda de j
                    left_r, left_c = i_r, i_c
                    right_r, right_c = j_r, j_c
                    left_to_right = True
                else:  # i está à direita de j
                    left_r, left_c = j_r, j_c
                    right_r, right_c = i_r, i_c
                    left_to_right = False
                    
                # Verificar se existe restrição horizontal
                if (left_r, left_c) in self.h_const:
                    ineq = self.h_const[(left_r, left_c)]
                    to_remove = set()
                    
                    if left_to_right:  # i está à esquerda de j
                        for val_i in list(self.domains[i_r][i_c]):
                            valid = False
                            
                            if j_value != 0:  # j já tem valor atribuído
                                if (ineq == 0 and val_i < j_value) or (ineq == 1 and val_i > j_value):
                                    valid = True
                                else:
                                    valid = False
                            else:  # j não tem valor atribuído
                                for val_j in self.domains[j_r][j_c]:
                                    if (ineq == 0 and val_i < val_j) or (ineq == 1 and val_i > val_j):
                                        valid = True
                                        break
                                        
                            if not valid:
                                to_remove.add(val_i)
                    
                    else:  # i está à direita de j
                        for val_i in list(self.domains[i_r][i_c]):
                            valid = False
                            
                            if j_value != 0:  # j já tem valor atribuído
                                if (ineq == 0 and val_i > j_value) or (ineq == 1 and val_i < j_value):
                                    valid = True
                                else:
                                    valid = False
                            else:  # j não tem valor atribuído
                                for val_j in self.domains[j_r][j_c]:
                                    if (ineq == 0 and val_i > val_j) or (ineq == 1 and val_i < val_j):
                                        valid = True
                                        break
                                        
                            if not valid:
                                to_remove.add(val_i)
                    
                    if to_remove:
                        self.domains[i_r][i_c] -= to_remove
                        revised = True
                        
                # Aplicar restrição de linha (valores diferentes na mesma linha)
                elif j_value != 0:  # Se j já tem valor
                    if j_value in self.domains[i_r][i_c]:
                        self.domains[i_r][i_c].remove(j_value)
                        revised = True
            
            # Se estamos na mesma coluna, verificar restrições verticais
            elif i_c == j_c and abs(i_r - j_r) == 1:
                # Determinar qual é cima e qual é baixo
                if i_r < j_r:  # i está acima de j
                    up_r, up_c = i_r, i_c
                    down_r, down_c = j_r, j_c
                    up_to_down = True
                else:  # i está abaixo de j
                    up_r, up_c = j_r, j_c
                    down_r, down_c = i_r, i_c
                    up_to_down = False
                    
                # Verificar se existe restrição vertical
                if (up_r, up_c) in self.v_const:
                    ineq = self.v_const[(up_r, up_c)]
                    to_remove = set()
                    
                    if up_to_down:  # i está acima de j
                        for val_i in list(self.domains[i_r][i_c]):
                            valid = False
                            
                            if j_value != 0:  # j já tem valor atribuído
                                if (ineq == 0 and val_i < j_value) or (ineq == 1 and val_i > j_value):
                                    valid = True
                                else:
                                    valid = False
                            else:  # j não tem valor atribuído
                                for val_j in self.domains[j_r][j_c]:
                                    if (ineq == 0 and val_i < val_j) or (ineq == 1 and val_i > val_j):
                                        valid = True
                                        break
                                        
                            if not valid:
                                to_remove.add(val_i)
                    
                    else:  # i está abaixo de j
                        for val_i in list(self.domains[i_r][i_c]):
                            valid = False
                            
                            if j_value != 0:  # j já tem valor atribuído
                                if (ineq == 0 and val_i > j_value) or (ineq == 1 and val_i < j_value):
                                    valid = True
                                else:
                                    valid = False
                            else:  # j não tem valor atribuído
                                for val_j in self.domains[j_r][j_c]:
                                    if (ineq == 0 and val_i > val_j) or (ineq == 1 and val_i < val_j):
                                        valid = True
                                        break
                                        
                            if not valid:
                                to_remove.add(val_i)
                    
                    if to_remove:
                        self.domains[i_r][i_c] -= to_remove
                        revised = True
                        
                # Aplicar restrição de coluna (valores diferentes na mesma coluna)
                elif j_value != 0:  # Se j já tem valor
                    if j_value in self.domains[i_r][i_c]:
                        self.domains[i_r][i_c].remove(j_value)
                        revised = True
                        
            # Aplicar restrições de linha e coluna para células não adjacentes
            elif i_r == j_r:  # Mesma linha
                if j_value != 0 and j_value in self.domains[i_r][i_c]:
                    self.domains[i_r][i_c].remove(j_value)
                    revised = True
            elif i_c == j_c:  # Mesma coluna
                if j_value != 0 and j_value in self.domains[i_r][i_c]:
                    self.domains[i_r][i_c].remove(j_value)
                    revised = True
                    
            return revised

        def chooseTargetVal(self):
            # Heurística MRV (Minimum Remaining Values) com desempate por Degree Heuristic
            mrv_lst = []
            least = self.size + 1  # Max domain size + 1

            for row in range(self.size):
                for col in range(self.size):
                    if self.puzzle[row][col] == 0:  # Consider only unassigned cells
                        curr_domain_len = len(self.domains[row][col])
                        if curr_domain_len < least:
                            least = curr_domain_len
                            mrv_lst = [(row, col)]
                        elif curr_domain_len == least:
                            mrv_lst.append((row, col))

            if not mrv_lst:  # Should not happen if puzzle is not complete
                self.target = (-1, -1)  # Indicate error or completion
                self.target_vals = []
                return

            # Degree Heuristic (desempate)
            if len(mrv_lst) > 1:
                degree_lst = []
                for r, c in mrv_lst:
                    degree = 0
                    # Conta vizinhos *não atribuídos*
                    # left
                    if c > 0 and self.puzzle[r][c-1] == 0: degree += 1
                    # right
                    if c < self.size - 1 and self.puzzle[r][c+1] == 0: degree += 1
                    # up
                    if r > 0 and self.puzzle[r-1][c] == 0: degree += 1
                    # down
                    if r < self.size - 1 and self.puzzle[r+1][c] == 0: degree += 1
                    degree_lst.append(degree)
                # Escolhe o com maior grau (mais restrições sobre vizinhos)
                self.target = mrv_lst[degree_lst.index(max(degree_lst))]
            else:
                self.target = mrv_lst[0]  # Só havia um com MRV

            # Pega os valores possíveis para o alvo escolhido
            # Implementando Least Constraining Value heuristic
            values = list(self.domains[self.target[0]][self.target[1]])
            
            # Ordenar por Least Constraining Value
            value_constraints = []
            for val in values:
                # Simular atribuição e contar quantos valores são removidos dos vizinhos
                constraints_count = 0
                
                # Criar cópia do tabuleiro e domínios para teste
                test_puzzle = copy.deepcopy(self.puzzle)
                test_domains = copy.deepcopy(self.domains)
                
                # Atribuir valor temporariamente
                r, c = self.target
                test_puzzle[r][c] = val
                
                # Verificar impacto nos vizinhos
                # Linha
                for nc in range(self.size):
                    if nc != c and test_puzzle[r][nc] == 0:
                        if val in test_domains[r][nc]:
                            constraints_count += 1
                
                # Coluna
                for nr in range(self.size):
                    if nr != r and test_puzzle[nr][c] == 0:
                        if val in test_domains[nr][c]:
                            constraints_count += 1
                
                value_constraints.append((val, constraints_count))
            
            # Ordenar por menor número de restrições
            value_constraints.sort(key=lambda x: x[1])
            self.target_vals = [vc[0] for vc in value_constraints]
            self.target_index = 0

        def isComplete(self):
            # Verifica se não há mais zeros no tabuleiro
            return not (0 in self.puzzle)

    # --- Fim da classe Board ---

    def __init__(self, initial_arr, h_const, v_const):
        self.root = self.Board(initial_arr, [], h_const, v_const)  # Passa array vazio para domains

    def solve(self):
        curr = self.root
        curr.initialize()  # Agora inicializa os domínios corretamente

        # Aplica consistência inicial
        if not curr.update():
            print("Puzzle inicial inconsistente.")
            return None

        node_visits = 0  # Contador para depuração
        max_node_visits = 1000000  # Limite para evitar execução indefinida (ajuste se necessário)

        start_time = time.time()

        while True:
            node_visits += 1
            if node_visits > max_node_visits:
                print(f"Limite de {max_node_visits} visitas atingido. Interrompendo.")
                print("Último estado:")
                printlst(curr.puzzle, sys.stdout)
                return None  # Parar

            if node_visits % 5000 == 0:  # Imprime progresso a cada 5000 nós
                elapsed = time.time() - start_time
                print(f"Visitas: {node_visits}... (Tempo: {elapsed:.2f}s)")

            if curr.isComplete():  # Já verifica a validade implicitamente pelas atualizações
                elapsed = time.time() - start_time
                print(f"\nSolução encontrada! Visitas: {node_visits} (Tempo: {elapsed:.2f}s)")
                return curr.puzzle

            # Escolhe a próxima variável e seus valores possíveis
            curr.chooseTargetVal()

            if curr.target == (-1, -1):  # Condição de parada se chooseTargetVal falhar
                print(f"[Visita {node_visits}] Erro: Nenhum alvo válido encontrado por chooseTargetVal.")
                # Força o backtrack (o código abaixo já faz isso se target_vals for vazio)
                pass

            # --- Tentativa e Descida ---
            # Verifica se ainda há valores a tentar para a variável atual (curr.target)
            if curr.target_vals and curr.target_index < len(curr.target_vals):
                # Cria um novo estado (nó filho)
                new_puzzle = copy.deepcopy(curr.puzzle)
                new_domains = copy.deepcopy(curr.domains)  # Copia domínios atuais

                # Atribui o próximo valor da lista target_vals
                val_to_try = curr.target_vals[curr.target_index]
                target_r, target_c = curr.target
                new_puzzle[target_r][target_c] = val_to_try
                new_domains[target_r][target_c] = {val_to_try}  # Domínio da célula atribuída fica com apenas o valor atribuído

                # Cria o nó filho
                child = self.Board(new_puzzle, new_domains, curr.h_const, curr.v_const, curr)

                # Tenta atualizar os domínios do filho (Forward Checking / Arc Consistency)
                if child.update():  # Se a atualização for bem-sucedida (estado consistente)
                    # Adiciona à lista de filhos APENAS se for válido descer
                    curr.children.append(child) 
                    curr = child  # Desce para o filho
                    # A próxima iteração do while vai escolher a próxima variável para este novo estado 'curr'
                else:
                    # Estado inconsistente, não desce. Incrementa o índice para tentar o próximo valor.
                    curr.target_index += 1
                    # Não adiciona o filho inválido à lista curr.children

            # --- Backtrack ---
            # Se não há mais valores a tentar para a variável atual (curr.target)
            # OU se update() falhou na tentativa anterior e incrementamos target_index além do limite
            else:
                if curr.parent is None:
                    elapsed = time.time() - start_time
                    print(f"\nBacktrack até a raiz sem solução. Visitas: {node_visits} (Tempo: {elapsed:.2f}s)")
                    return None  # Sem solução

                # Limpa filhos do nó atual antes de subir (economia de memória)
                curr.children = []

                curr = curr.parent  # Sobe para o pai
                curr.target_index += 1  # Incrementa o índice do pai para tentar o próximo valor *dele*
                # A próxima iteração do while vai tentar o próximo valor do pai ou subir mais se necessário
# --- Fim da classe BackTracker ---


def gen_constraints(horiz, vert):
    HConstraints = {}
    VConstraints = {}
    # Mapeia símbolos para 0 (menor) ou 1 (maior) para a célula da *esquerda* ou de *cima*
    # '<' : célula esquerda é MENOR (0)
    # '>' : célula esquerda é MAIOR (1)
    # 'v' : célula de cima é MENOR (0)
    # '^' : célula de cima é MAIOR (1)
    constraint_dict = {'^': 1, '>': 1, '<': 0, 'v': 0}

    # Restrições Horizontais (entre colunas)
    # horiz[linha] contém restrições para a linha 'linha'
    # O caracter em horiz[linha][col] é a restrição entre puzzle[linha][col] e puzzle[linha][col+1]
    for r in range(len(horiz)):  # Itera pelas linhas de restrições H
        line_constraints = horiz[r]
        for c in range(len(line_constraints)):  # Itera pelas posições de restrição na linha
            if c < len(line_constraints):
                symbol = line_constraints[c]
                if symbol in constraint_dict:
                    # A chave é a coordenada da célula à ESQUERDA da restrição
                    HConstraints[(r, c)] = constraint_dict[symbol]

    # Restrições Verticais (entre linhas)
    # vert[linha] contém restrições entre a linha 'linha' e 'linha+1'
    # O caracter em vert[linha][col] é a restrição entre puzzle[linha][col] e puzzle[linha+1][col]
    for r in range(len(vert)):  # Itera pelas linhas de restrições V
        line_constraints = vert[r]
        for c in range(len(line_constraints)):  # Itera pelas colunas
            if c < len(line_constraints):
                symbol = line_constraints[c]
                if symbol in constraint_dict:
                    # A chave é a coordenada da célula de CIMA da restrição
                    VConstraints[(r, c)] = constraint_dict[symbol]

    return [HConstraints, VConstraints]

def main():
    parser = argparse.ArgumentParser(description=f'Resolvedor de Futoshiki {SIZE}x{SIZE}')
    parser.add_argument('--infile', type=argparse.FileType('r'), required=True, help='Arquivo de entrada do puzzle')
    parser.add_argument('--outfile', type=argparse.FileType('w'), default=sys.stdout, help='Arquivo de saída da solução (padrão: stdout)')
    args = parser.parse_args()

    try:
        infile_content = args.infile.read().splitlines()  # Lê tudo e divide por linhas
        args.infile.close()  # Fecha o arquivo
    except Exception as e:
        print(f"Erro ao ler o arquivo de entrada: {e}")
        sys.exit(1)

    # Remove linhas em branco do conteúdo lido
    lines_raw = [line for line in infile_content if line.strip()]

    # Processamento do formato do arquivo
    # Tentativa para ambos os formatos (com e sem linhas em branco)
    if len(lines_raw) >= 3*SIZE-1:  # Formato compacto
        print("Usando formato compacto (sem linhas em branco separadoras).")
        puzzle_raw = lines_raw[0:SIZE]
        horiz_raw = lines_raw[SIZE:SIZE*2]
        vert_raw = lines_raw[SIZE*2:SIZE*3-1]
    else:
        print("ERRO: Arquivo com formato inválido ou sem linhas suficientes.")
        sys.exit(1)

    # Processamento dos dados
    try:
        # Converter strings para listas de valores
        puzzle_lists = []
        for row in puzzle_raw:
            # Separa por espaços e converte para int, '0' para células vazias
            puzzle_lists.append([int(cell) if cell.isdigit() else 0 for cell in row.split()])
        
        # Verificar se temos 4x4 células
        if len(puzzle_lists) != SIZE or any(len(row) != SIZE for row in puzzle_lists):
            raise ValueError(f"Formato incorreto no tabuleiro do puzzle. Deve ser {SIZE}x{SIZE}.")
        
        # Converte para numpy array
        inpdata = np.array(puzzle_lists, dtype=int)
    except Exception as e:
        print(f"Erro ao processar o tabuleiro do puzzle: {e}")
        print("Dados recebidos para o tabuleiro:")
        for row in puzzle_raw:
            print(row)
        sys.exit(1)

    # Processa restrições horizontais e verticais
    horiz_str = []
    for row in horiz_raw:
        symbols = row.split()
        if len(symbols) != SIZE-1:
            print(f"AVISO: Linha de restrição horizontal com formato incorreto: {row}")
            # Completa com espaços ou corta para o tamanho correto
            symbols = (symbols + [' '] * SIZE)[:SIZE-1]
        horiz_str.append(''.join(symbols))

    vert_str = []
    for row in vert_raw:
        symbols = row.split()
        if len(symbols) != SIZE:
            print(f"AVISO: Linha de restrição vertical com formato incorreto: {row}")
            # Completa com espaços ou corta para o tamanho correto
            symbols = (symbols + [' '] * SIZE)[:SIZE]
        vert_str.append(''.join(symbols))

    # Gera os dicionários de restrições
    constraints = gen_constraints(horiz_str, vert_str)
    h_const = constraints[0]
    v_const = constraints[1]

    print("--- Puzzle Inicial ---")
    printlst(inpdata, sys.stdout)
    print("--- Restrições H ---")
    print(h_const)
    print("--- Restrições V ---")
    print(v_const)
    print("----------------------")
    print("Resolvendo...")

    solver = BackTracker(inpdata, h_const, v_const)
    solution = solver.solve()

    print("--- Solução ---")
    if solution is not None:
        printlst(solution, args.outfile)
        print(f"Solução escrita em: {args.outfile.name if args.outfile != sys.stdout else 'Console'}")
    else:
        print("Não foi possível encontrar uma solução.")
        args.outfile.write("Sem solucao\n")

    if args.outfile != sys.stdout:
        args.outfile.close()  # Fecha o arquivo de saída se não for stdout

if __name__ == "__main__":
    main()